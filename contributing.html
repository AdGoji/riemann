---
title: Riemann - Contributing
layout: default
---
<h1>(apply within <span class="focus">hackers</span>)</h1>

<p>I built Riemann to solve my problems, but I want it to work for you,
too. If you use Riemann, <a href="mailto:aphyr@aphyr.com">send me an
  email</a> about how it's working for you, or what needs to change</a>. Frustrated with the API? Find a bug? <a href="https://github.com/aphyr/riemann/issues">Open an issue</a>.</p>

<p class="callout">The best way to say "thank you" is to contribute code. <a href="https://github.com/aphyr/riemann">It's all on Github</a>.</p>

<div class="cards">
  <div class="card">
    <h2>Building</h2>
    <p>The protocol classes and client are required by riemann itself. You'll
    need <a
      href="http://code.google.com/p/protobuf/downloads/detail?name=protobuf-2.3.0.tar.bz2&can=2&q=">protoc 2.3.0</a>.</p>

    <code><pre>git clone git://github.com/aphyr/riemann-java-client.git
cd riemann-java-client
mvn package
mvn install</pre></code>

    <code><pre>git clone git://github.com/aphyr/riemann.git</pre></code>

    <p>Riemann uses <a
      href="https://github.com/technomancy/leiningen">Leiningen</a>, the
    Clojure build tool. First, fetch dependencies:</p>

    <code><pre>lein deps</pre></code>

    <p>Build the java query parser:</p>
    <code><pre>lein javac</pre></code>

    <p>And run the test suite:</p>
    <code><pre>lein test</pre></code>

    <p>Or, for a specific namespace:</p>
    <code><pre>lein test riemann.test.streams</pre></code>

    <p>I'm really sorry about this, but there are some poorly-written
    tests for time-dependent streams like rates and percentiles. These
    can be finicky; I'm working on rewriting them as soon as possible.
    Some tests also rely on a local graphite install or sendmail; you can
    ignore them if you aren't changing those components.</p>

    <p>You can run the server with</p>

    <code><pre>lein run riemann.config</pre></code>

    <p>and when you're ready to package, just <code>lein package</code>
    to build both regular and standalone jars, a debian package, tarball,
    and pom.xml.</p>
  </div>

  <div class="card">
    <h2>Pull Requests</h2>
    
    <p>When you've made your changes (for anything non-trivial, on a
    topic branch, please), send me a pull request on Github. Please run
    the test suite before submitting, and keep your commits focused.</p>
  </div>

  <div class="card">
    <h2><a name="protocol" style="color: inherit">Protocol</a></h2>
    
    <p>A connection to Riemann is a stream of messages. Each message is a
    4 byte network-endian integer *length*, followed by a Protocol Buffer
    Message of *length* bytes. See <a
      href="https://github.com/aphyr/riemann/blob/master/proto/riemann/proto.proto">proto/riemann/proto.proto</a>
    for the protobuf particulars.</p>

    <p>Over UDP, the length header is omitted; just send the protobuf
    directly. UDP datagrams have a default maximum size of 16384 bytes by
    Riemann's default; larger messages should go over TCP. This limit is
    configurable in both the client and server.</p>

    <p>The server will accept a repeated list of Events, and respond with
    a confirmation message with either an acknowledgement or an error.
    Check the `ok` boolean in the message; if false, message.error will
    be a descriptive string.</p>

    <p>Because protocol buffers is strongly typed, the metric field is
    represented on the wire as metric_f. At some point I'll add an int64
    as well.</p>

    <p>Events are uniquely identified by host and service. Both allow
    null.  Event.time is the time in unix epoch seconds and is optional.
    The server will generate a time for each event when received if you
    do not provide one. I don't need time resolution finer than 1 second
    presently, but if you do, my plan is to add a nanosecond field as
    well.</p>

    <p>You can also query events from the index using a basic query
    language. Just submit a Message with your query in
    message.query.string. Search queries will return a message with
    repeated Events matching that expression. A
null expression will return no states.</p>
  </div>

  <div class="card">
    <h2>Thanks</h2>

    <p>MÃ¥rten Gustafson started work on the Java client.</p>

    <p>Paul Butcher fixed a typo in the quickstart.</p>

    <p>Obfuscurity and Lusis contributed ideas for HA failover and peer
    discovery.</p>

    <p>Lusis wrote an adapter between <a
      href="http://logstash.net/">logstash</a> and Riemann.</p>

    <p>Eric Lindvall (lindvall) updated riak-ruby-client to be
    1.8-compatible.</p>

    <h3>0.1.0</h3>

    <p>#flatland, #clojure and #leiningen, including jodaro, ninjudd,
    raynes, and amalloy, helped with protobufs parsing, leiningen, and
    general Clojure questions.</p>

    <p><a href="http://showyou.com">Showyou</a>, my employer, gave me the
    infrastructure I needed Riemann for, and the chance to share it with
    the world.</p>

    <p>John Mullerleile (jrecursive) was deeply involved in talking
    through the concept and structure of Riemann, as well as advice
    around the JVM and profiling.</p>

    <p>C Scott Andreas (cscotta) and the <a
      href="http://boundary.com">Boundary</a> crew gave many helpful
    suggestions around the JVM, Maven, high_scale_lib, and profiling. Our
    conversations yielded many references, algorithms and ideas.</p>

    <p>Allen Rohner (arohner) on #clojure offered a logging configuration
    snippet.</p>

    <p>Ryan Grove and Sean Cribbs gave feedback on documentation and
    design.</p>

    <p>Reid Draper contributed a syntactic patch.</p>

    <p>Sam Newman (snewman) brought Riemann up to speed with Clojure
    1.3.</p>

    <p>Tyler Schuett offered graphic design advice.</p>

    <p>Gleicon wrote the Python client.</p>
  </div>
</div>
