<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>riemann.streams documentation</title></head><body><div id="header"><h1><a href="index.html">Riemann 0.1.3 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="riemann.bin.html"><span>riemann.bin</span></a></li><li><a href="riemann.common.html"><span>riemann.common</span></a></li><li><a href="riemann.config.html"><span>riemann.config</span></a></li><li><a href="riemann.core.html"><span>riemann.core</span></a></li><li><a href="riemann.deps.html"><span>riemann.deps</span></a></li><li><a href="riemann.email.html"><span>riemann.email</span></a></li><li><a href="riemann.folds.html"><span>riemann.folds</span></a></li><li><a href="riemann.graphite.html"><span>riemann.graphite</span></a></li><li><a href="riemann.index.html"><span>riemann.index</span></a></li><li><a href="riemann.librato.html"><span>riemann.librato</span></a></li><li><a href="riemann.logging.html"><span>riemann.logging</span></a></li><li><a href="riemann.pagerduty.html"><span>riemann.pagerduty</span></a></li><li><a href="riemann.pool.html"><span>riemann.pool</span></a></li><li><a href="riemann.pubsub.html"><span>riemann.pubsub</span></a></li><li><a href="riemann.query.html"><span>riemann.query</span></a></li><li><a href="riemann.server.html"><span>riemann.server</span></a></li><li class="current"><a href="riemann.streams.html"><span>riemann.streams</span></a></li><li><a href="riemann.time.html"><span>riemann.time</span></a></li><li><a href="riemann.time.controlled.html"><span>riemann.time.controlled</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="riemann.streams.html#var-adjust"><span>adjust</span></a></li><li><a href="riemann.streams.html#var-append"><span>append</span></a></li><li><a href="riemann.streams.html#var-by"><span>by</span></a></li><li><a href="riemann.streams.html#var-call-rescue"><span>call-rescue</span></a></li><li><a href="riemann.streams.html#var-changed"><span>changed</span></a></li><li><a href="riemann.streams.html#var-changed-state"><span>changed-state</span></a></li><li><a href="riemann.streams.html#var-coalesce"><span>coalesce</span></a></li><li><a href="riemann.streams.html#var-combine"><span>combine</span></a></li><li><a href="riemann.streams.html#var-counter"><span>counter</span></a></li><li><a href="riemann.streams.html#var-ddt"><span>ddt</span></a></li><li><a href="riemann.streams.html#var-default"><span>default</span></a></li><li><a href="riemann.streams.html#var-delete-from-index"><span>delete-from-index</span></a></li><li><a href="riemann.streams.html#var-ewma-timeless"><span>ewma-timeless</span></a></li><li><a href="riemann.streams.html#var-expired"><span>expired</span></a></li><li><a href="riemann.streams.html#var-expired%3F"><span>expired?</span></a></li><li><a href="riemann.streams.html#var-fill-in"><span>fill-in</span></a></li><li><a href="riemann.streams.html#var-fill-in-last"><span>fill-in-last</span></a></li><li><a href="riemann.streams.html#var-fixed-event-window"><span>fixed-event-window</span></a></li><li><a href="riemann.streams.html#var-fixed-time-window"><span>fixed-time-window</span></a></li><li><a href="riemann.streams.html#var-fold-interval"><span>fold-interval</span></a></li><li><a href="riemann.streams.html#var-forward"><span>forward</span></a></li><li><a href="riemann.streams.html#var-interpolate-constant"><span>interpolate-constant</span></a></li><li><a href="riemann.streams.html#var-match"><span>match</span></a></li><li><a href="riemann.streams.html#var-mean-over-time"><span>mean-over-time</span></a></li><li><a href="riemann.streams.html#var-moving-event-window"><span>moving-event-window</span></a></li><li><a href="riemann.streams.html#var-moving-time-window"><span>moving-time-window</span></a></li><li><a href="riemann.streams.html#var-over"><span>over</span></a></li><li><a href="riemann.streams.html#var-part-time-fast"><span>part-time-fast</span></a></li><li><a href="riemann.streams.html#var-percentiles"><span>percentiles</span></a></li><li><a href="riemann.streams.html#var-periodically-until-expired"><span>periodically-until-expired</span></a></li><li><a href="riemann.streams.html#var-rate"><span>rate</span></a></li><li><a href="riemann.streams.html#var-register"><span>register</span></a></li><li><a href="riemann.streams.html#var-rollup"><span>rollup</span></a></li><li><a href="riemann.streams.html#var-smap"><span>smap</span></a></li><li><a href="riemann.streams.html#var-sreduce"><span>sreduce</span></a></li><li><a href="riemann.streams.html#var-sum-over-time"><span>sum-over-time</span></a></li><li><a href="riemann.streams.html#var-tagged"><span>tagged</span></a></li><li><a href="riemann.streams.html#var-tagged-all"><span>tagged-all</span></a></li><li><a href="riemann.streams.html#var-tagged-any"><span>tagged-any</span></a></li><li><a href="riemann.streams.html#var-throttle"><span>throttle</span></a></li><li><a href="riemann.streams.html#var-under"><span>under</span></a></li><li><a href="riemann.streams.html#var-update-index"><span>update-index</span></a></li><li><a href="riemann.streams.html#var-where"><span>where</span></a></li><li><a href="riemann.streams.html#var-where*"><span>where*</span></a></li><li><a href="riemann.streams.html#var-where-partition-clauses"><span>where-partition-clauses</span></a></li><li><a href="riemann.streams.html#var-where-rewrite"><span>where-rewrite</span></a></li><li><a href="riemann.streams.html#var-window"><span>window</span></a></li><li><a href="riemann.streams.html#var-with"><span>with</span></a></li><li><a href="riemann.streams.html#var-within"><span>within</span></a></li><li><a href="riemann.streams.html#var-without"><span>without</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>riemann.streams documentation</h2><pre class="doc"></pre><div class="public" id="var-adjust"><h3>adjust</h3><div class="usage"><code>(adjust &amp; args)</code></div><pre class="doc">Passes on a changed version of each event by applying a function to a
particular field or to the event as a whole.

Passing a vector of [field function &amp; args] to adjust will modify the given
field in incoming events by applying the function to it along with the given
arguments.  For example:

(adjust [:service str &quot; rate&quot;] ...)

takes {:service &quot;foo&quot;} and emits {:service &quot;foo rate&quot;}.

If a function is passed to adjust instead of a vector, adjust behaves like
smap: the entire event will be given to the function and the result will be
passed along to the children. For example:

(adjust #(assoc % :metric (count (:tags %))) ...)

takes {:tags [&quot;foo&quot; &quot;bar&quot;]} and emits {:tags [&quot;foo&quot; &quot;bar&quot;] :metric 2}.

Prefer (smap f &amp; children) to (adjust f &amp; children) where possible.</pre></div><div class="public" id="var-append"><h3>append</h3><div class="usage"><code>(append reference)</code></div><pre class="doc">Conj events onto the given reference
</pre></div><div class="public" id="var-by"><h3>by</h3><div class="usage"><code>(by fields &amp; children)</code></div><pre class="doc">Splits stream by field.
Every time an event arrives with a new value of field, this macro invokes
its child forms to return a *new*, distinct set of streams for that
particular value.

(rate 5 prn) prints a single rate for all events, once every five seconds.

(by :host (rate 5) tracks a separate rate for *each host*, and prints each
one every five seconds.

You can pass multiple fields too

(by [:host :service])

Note that field can be a keyword like :host or :state, but you can *also* use
any unary function for more complex sharding.

Be aware that (by) over unbounded values can result in
*many* substreams being created, so you wouldn't want to write
(by metric prn): you'd get a separate prn for *every* unique metric that
came in.</pre></div><div class="public" id="var-call-rescue"><h3>call-rescue</h3><div class="usage"><code>(call-rescue event children)</code></div><pre class="doc">Call each child, in order, with event. Rescues and logs any failure.
</pre></div><div class="public" id="var-changed"><h3>changed</h3><div class="usage"><code>(changed pred &amp; children)</code></div><pre class="doc">Passes on events only when (f event) differs from that of the previous
event. Options:

:init   The initial value to assume for (pred event).

; Print all state changes
(changed :state prn)

; Assume states *were* ok the first time we see them.
(changed :state {:init &quot;ok&quot;} prn)

Note that f can be an arbitrary function:

(changed (fn [e] (&gt; (:metric e) 2)) ...)</pre></div><div class="public" id="var-changed-state"><h3>changed-state</h3><div class="usage"><code>(changed-state &amp; children)</code></div><pre class="doc">Passes on changes in state for each distinct host and service.
</pre></div><div class="public" id="var-coalesce"><h3>coalesce</h3><div class="usage"><code>(coalesce &amp; children)</code></div><pre class="doc">Combines events over time. Coalesce remembers the most recent event for each
service that passes through it (limited by :ttl). Every time it receives an
event, it passes on *all* events it remembers.

Use coalesce to combine states that arrive at different times--for instance,
to average the CPU use over several hosts.</pre></div><div class="public" id="var-combine"><h3>combine</h3><div class="usage"><code>(combine f &amp; children)</code></div><pre class="doc">Returns a function which takes a seq of events. Combines events with f, then
forwards the result to children.</pre></div><div class="public" id="var-counter"><h3>counter</h3><div class="usage"><code>(counter &amp; children)</code></div><pre class="doc">Counts things. All metrics are summed together; passes on each event with
the summed metric. When an event has tag &quot;reset&quot;, resets the counter to
zero and continues summing.</pre></div><div class="public" id="var-ddt"><h3>ddt</h3><div class="usage"><code>(ddt &amp; args)</code></div><pre class="doc">Differentiate metrics with respect to time. With no args, emits an event for
each one received, but with metric equal to the difference between the
current event and the previous one, divided by the difference in their times.
If the first argument is a number n, emits a rate-of-change event every n
seconds instead, until expired. Skips events without metrics.</pre></div><div class="public" id="var-default"><h3>default</h3><div class="usage"><code>(default &amp; args)</code></div><pre class="doc">Transforms an event by associng a set of new key:value pairs, wherever the
event has a nil value for that key. Passes the result on to children. Use:

(default :service &quot;foo&quot; prn)
(default :service &quot;jrecursive&quot; :state &quot;chicken&quot;} prn)</pre></div><div class="public" id="var-delete-from-index"><h3>delete-from-index</h3><div class="usage"><code>(delete-from-index index)</code></div><pre class="doc">Deletes any events that pass through from the index
</pre></div><div class="public" id="var-ewma-timeless"><h3>ewma-timeless</h3><div class="usage"><code>(ewma-timeless r &amp; children)</code></div><pre class="doc">Exponential weighted moving average. Constant space and time overhead.
Passes on each event received, but with metric adjusted to the moving
average. Does not take the time between events into account.</pre></div><div class="public" id="var-expired"><h3>expired</h3><div class="usage"><code>(expired &amp; children)</code></div><pre class="doc">Passes on events with :state &quot;expired&quot;.
</pre></div><div class="public" id="var-expired%3F"><h3>expired?</h3><div class="usage"><code>(expired? event)</code></div><pre class="doc">There are two ways an event can be considered expired. First, if it has state &quot;expired&quot;. Second, if its :ttl and :time indicates it has expired.
</pre></div><div class="public" id="var-fill-in"><h3>fill-in</h3><div class="usage"><code>(fill-in interval default-event &amp; children)</code></div><pre class="doc">Passes on all events. Fills in gaps in event stream with copies of the given
event, wherever interval seconds pass without an event arriving. Inserted
events have current time. Stops inserting when expired. Uses local times.</pre></div><div class="public" id="var-fill-in-last"><h3>fill-in-last</h3><div class="usage"><code>(fill-in-last interval update &amp; children)</code></div><pre class="doc">Passes on all events. Fills in gaps in event stream with copies of the last
event merged with the given data, wherever interval seconds pass without an
event arriving. Inserted events have current time. Stops inserting when
expired. Uses local times.</pre></div><div class="public" id="var-fixed-event-window"><h3>fixed-event-window</h3><div class="usage"><code>(fixed-event-window n &amp; children)</code></div><pre class="doc">Passes on fixed-size windows of n events each. Accumulates n events, then
calls children with a vector of those events, from oldest to newest. Ignores
event times. Example:

(fixed-event-window 5 (combine folds/mean index))</pre></div><div class="public" id="var-fixed-time-window"><h3>fixed-time-window</h3><div class="usage"><code>(fixed-time-window n &amp; children)</code></div><pre class="doc">A fixed window over the event stream in time. Emits vectors of events, such
that each vector has events from a distinct n-second interval. Windows do
*not* overlap; each event appears at most once in the output stream. Once an
event is emitted, all events *older or equal* to that emitted event are
silently dropped.

Events without times accrue in the current window.</pre></div><div class="public" id="var-fold-interval"><h3>fold-interval</h3><div class="usage"><code>(fold-interval interval event-key folder &amp; children)</code></div><pre class="doc">Applies the folder function to all event-key values of events during
interval seconds.</pre></div><div class="public" id="var-forward"><h3>forward</h3><div class="usage"><code>(forward client)</code></div><pre class="doc">Sends an event through a client
</pre></div><div class="public" id="var-interpolate-constant"><h3>interpolate-constant</h3><div class="usage"><code>(interpolate-constant interval &amp; children)</code></div><pre class="doc">Emits a constant stream of events every interval seconds, starting when an
event is received, and ending when an expired event is received. Times are
set to Riemann's time. The first and last events are forwarded immediately.

Note: ignores event times currently--will change later.</pre></div><div class="public" id="var-match"><h3>match</h3><div class="usage"><code>(match f value &amp; children)</code></div><pre class="doc">Passes events on to children only when (f event) matches value, using
riemann.common/match. For instance:

(match :service nil prn)
(match :state #{&quot;warning&quot; &quot;critical&quot;} prn)
(match :description #&quot;error&quot; prn)
(match :metric 5 prn)
(match expired? true prn)
(match (fn [e] (/ (:metric e) 1000)) 5 prn)

For cases where you only care about whether (f event) is truthy, use (where
some-fn) instead of (match some-fn true).</pre></div><div class="public" id="var-mean-over-time"><h3>mean-over-time</h3><div class="usage"><code>(mean-over-time children)</code></div><pre class="doc">Emits the most recent event each time this stream is called, but with the
average of all received metrics.</pre></div><div class="public" id="var-moving-event-window"><h3>moving-event-window</h3><div class="usage"><code>(moving-event-window n &amp; children)</code></div><pre class="doc">A sliding window of the last few events. Every time an event arrives, calls
children with a vector of the last n events, from oldest to newest. Ignores
event times. Example:

(moving-event-window 5 (combine folds/mean index))</pre></div><div class="public" id="var-moving-time-window"><h3>moving-time-window</h3><div class="usage"><code>(moving-time-window n &amp; children)</code></div><pre class="doc">A sliding window of all events with times within the last n seconds. Uses
the maximum event time as the present-time horizon. Every time a new event
arrives within the window, emits a vector of events in the window to
children.

Events without times accrue in the current window.</pre></div><div class="public" id="var-over"><h3>over</h3><div class="usage"><code>(over x &amp; children)</code></div><pre class="doc">Passes on events only when their metric is greater than x
</pre></div><div class="public" id="var-part-time-fast"><h3>part-time-fast</h3><div class="usage"><code>(part-time-fast interval create add finish)</code></div><pre class="doc">Partitions events by time (fast variant). Each &lt;interval&gt; seconds, creates a
new bin by calling (create). Applies each received event to the current bin
with (add bin event). When the time interval is over, calls (finish bin
start-time elapsed-time).</pre></div><div class="public" id="var-percentiles"><h3>percentiles</h3><div class="usage"><code>(percentiles interval points &amp; children)</code></div><pre class="doc">Over each period of interval seconds, aggregates events and selects one
event from that period for each point. If point is 0, takes the lowest metric
event.  If point is 1, takes the highest metric event. 0.5 is the median
event, and so forth. Forwards each of these events to children. The service
name has the point appended to it; e.g. 'response time' becomes 'response
time .95'.</pre></div><div class="public" id="var-periodically-until-expired"><h3>periodically-until-expired</h3><div class="usage"><code>(periodically-until-expired f)</code><code>(periodically-until-expired interval f)</code><code>(periodically-until-expired interval delay f)</code></div><pre class="doc">When an event arrives, begins calling f every interval seconds. Starts
after delay. Stops calling f when an expired? event arrives.</pre></div><div class="public" id="var-rate"><h3>rate</h3><div class="usage"><code>(rate interval &amp; children)</code></div><pre class="doc">Take the sum of every event over interval seconds and divide by the interval
size.</pre></div><div class="public" id="var-register"><h3>register</h3><div class="usage"><code>(register reference)</code></div><pre class="doc">Set reference to the most recent event that passes through.
</pre></div><div class="public" id="var-rollup"><h3>rollup</h3><div class="usage"><code>(rollup n m &amp; children)</code></div><pre class="doc">Invokes children with events at most n times per m second interval. Passes
*vectors* of events to children, not a single event at a time. For instance,
(rollup 3 1 f) receives five events and forwards three times per second:

1 -&gt; (f [1])
2 -&gt; (f [2])
3 -&gt; (f [3])
4 -&gt;
5 -&gt;

... and events 4 and 5 are rolled over into the next period:

  -&gt; (f [4 5])</pre></div><div class="public" id="var-smap"><h3>smap</h3><div class="usage"><code>(smap f &amp; children)</code></div><pre class="doc">Streaming map. Calls children with (f event). Prefer this to (adjust f).
Example:

(smap :metric prn) ; prints the metric of each event.
(smap #(assoc % :state &quot;ok&quot;) index) ; Indexes each event with state &quot;ok&quot;</pre></div><div class="public" id="var-sreduce"><h3>sreduce</h3><div class="usage"><code>(sreduce f &amp; opts)</code></div><pre class="doc">Streaming reduce. Two forms:

(sreduce f child1 child2 ...)
(sreduce f val child1 child2 ...)

Maintains an internal value, which defaults to the first event received or,
if provided, val. When the stream receives an event, calls (f val event) to
produce a new value, which is sent to each child. f *must* be free of side
effects. Examples:

Passes on events, but with the *maximum* of all received metrics:
(sreduce (fn [acc event] (assoc event :metric
                                (+ (:metric event) (:metric acc)))) ...)

Or, using riemann.folds, a simple moving average:
(sreduce (fn [acc event] (folds/mean [acc event])) ...)</pre></div><div class="public" id="var-sum-over-time"><h3>sum-over-time</h3><div class="usage"><code>(sum-over-time &amp; children)</code></div><pre class="doc">Sums all metrics together. Emits the most recent event each time this
stream is called, but with summed metric.</pre></div><div class="public" id="var-tagged"><h3>tagged</h3><div class="usage"></div><pre class="doc">Alias for tagged-all
</pre></div><div class="public" id="var-tagged-all"><h3>tagged-all</h3><div class="usage"><code>(tagged-all tags &amp; children)</code></div><pre class="doc">Passes on events where all tags are present.

(tagged-all &quot;foo&quot; prn)
(tagged-all [&quot;foo&quot; &quot;bar&quot;] prn)</pre></div><div class="public" id="var-tagged-any"><h3>tagged-any</h3><div class="usage"><code>(tagged-any tags &amp; children)</code></div><pre class="doc">Passes on events where any of tags are present.

(tagged-any &quot;foo&quot; prn)
(tagged-all [&quot;foo&quot; &quot;bar&quot;] prn)</pre></div><div class="public" id="var-throttle"><h3>throttle</h3><div class="usage"><code>(throttle n m &amp; children)</code></div><pre class="doc">Passes on n events every m seconds. Drops events when necessary.
</pre></div><div class="public" id="var-under"><h3>under</h3><div class="usage"><code>(under x &amp; children)</code></div><pre class="doc">Passes on events only when their metric is smaller than x
</pre></div><div class="public" id="var-update-index"><h3>update-index</h3><div class="usage"><code>(update-index index)</code></div><pre class="doc">Updates the given index with all events received.
</pre></div><div class="public" id="var-where"><h3>where</h3><div class="usage"><code>(where expr &amp; children)</code></div><pre class="doc">Passes on events where expr is true. Expr is rewritten using where-rewrite.
'event is bound to the event under consideration. Examples:

; Match any event where metric is either 1, 2, 3, or 4.
(where (metric 1 2 3 4) ...)

; Match a event where the metric is negative AND the state is ok.
(where (and (&gt; 0 metric)
            (state &quot;ok&quot;)) ...)

; Match a event where the host begins with web
(where (host #&quot;^web&quot;) ...)

If a child begins with (else ...), the else's body is executed when expr is
false. For instance:

(where (service &quot;www&quot;)
  (notify-www-team)
  (else
    (notify-misc-team)))</pre></div><div class="public" id="var-where*"><h3>where*</h3><div class="usage"><code>(where* f &amp; children)</code></div><pre class="doc">A simpler, less magical variant of (where). Instead of binding symbols in
the context of an expression, where* takes a function which takes an event.
When (f event) is truthy, passes event to children--and otherwise, passes
event to (else ...) children. For example:

(where* (fn [e] (&lt; 2 (:metric e))) prn)

(where* expired? 
  (partial prn &quot;Expired&quot;)
  (else
    (partial prn &quot;Not expired!&quot;)))</pre></div><div class="public" id="var-where-partition-clauses"><h3>where-partition-clauses</h3><div class="usage"><code>(where-partition-clauses exprs)</code></div><pre class="doc">Given expressions like (a (else b) c (else d)), returns [[a c] [b d]]
</pre></div><div class="public" id="var-where-rewrite"><h3>where-rewrite</h3><div class="usage"><code>(where-rewrite expr)</code></div><pre class="doc">Rewrites lists recursively. Replaces (metric x y z) with a test matching
(:metric event) to any of x, y, or z, either by = or re-find. Replaces any
other instance of metric with (:metric event). Does the same for host,
service, event, state, time, ttl, tags (which performs an exact match of the
tag vector), tagged (which checks to see if the given tag is present at all),
metric_f, and description.</pre></div><div class="public" id="var-window"><h3>window</h3><div class="usage"><code>(window n &amp; children)</code></div><pre class="doc">Alias for moving-event-window.
</pre></div><div class="public" id="var-with"><h3>with</h3><div class="usage"><code>(with &amp; args)</code></div><pre class="doc">Transforms an event by associng a set of new k:v pairs, and passes the
result to children. Use:

(with :service &quot;foo&quot; prn)
(with {:service &quot;foo&quot; :state &quot;broken&quot;} prn)</pre></div><div class="public" id="var-within"><h3>within</h3><div class="usage"><code>(within r &amp; children)</code></div><pre class="doc">Passes on events only when their metric falls within the given inclusive
range.

(within [0 1] (fn [event] do-something))</pre></div><div class="public" id="var-without"><h3>without</h3><div class="usage"><code>(without r &amp; children)</code></div><pre class="doc">Passes on events only when their metric falls outside the given (inclusive)
range.</pre></div></div></body></html>