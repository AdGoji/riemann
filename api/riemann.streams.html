<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>riemann.streams documentation</title></head><body><div id="header"><h1><a href="index.html">Riemann 0.1.3-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="leiningen.build-parser.html"><span>leiningen.build-parser</span></a></li><li><a href="riemann.bin.html"><span>riemann.bin</span></a></li><li><a href="riemann.client.html"><span>riemann.client</span></a></li><li><a href="riemann.common.html"><span>riemann.common</span></a></li><li><a href="riemann.config.html"><span>riemann.config</span></a></li><li><a href="riemann.core.html"><span>riemann.core</span></a></li><li><a href="riemann.email.html"><span>riemann.email</span></a></li><li><a href="riemann.folds.html"><span>riemann.folds</span></a></li><li><a href="riemann.graphite.html"><span>riemann.graphite</span></a></li><li><a href="riemann.index.html"><span>riemann.index</span></a></li><li><a href="riemann.logging.html"><span>riemann.logging</span></a></li><li><a href="riemann.pagerduty.html"><span>riemann.pagerduty</span></a></li><li><a href="riemann.periodic.html"><span>riemann.periodic</span></a></li><li><a href="riemann.pubsub.html"><span>riemann.pubsub</span></a></li><li><a href="riemann.query.html"><span>riemann.query</span></a></li><li><a href="riemann.server.html"><span>riemann.server</span></a></li><li class="current"><a href="riemann.streams.html"><span>riemann.streams</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="riemann.streams.html#var-append"><span>append</span></a></li><li><a href="riemann.streams.html#var-by"><span>by</span></a></li><li><a href="riemann.streams.html#var-call-rescue"><span>call-rescue</span></a></li><li><a href="riemann.streams.html#var-changed"><span>changed</span></a></li><li><a href="riemann.streams.html#var-changed-state"><span>changed-state</span></a></li><li><a href="riemann.streams.html#var-coalesce"><span>coalesce</span></a></li><li><a href="riemann.streams.html#var-combine"><span>combine</span></a></li><li><a href="riemann.streams.html#var-counter"><span>counter</span></a></li><li><a href="riemann.streams.html#var-ddt"><span>ddt</span></a></li><li><a href="riemann.streams.html#var-delete-from-index"><span>delete-from-index</span></a></li><li><a href="riemann.streams.html#var-ewma-timeless"><span>ewma-timeless</span></a></li><li><a href="riemann.streams.html#var-expired"><span>expired</span></a></li><li><a href="riemann.streams.html#var-expired%3F"><span>expired?</span></a></li><li><a href="riemann.streams.html#var-fill-in"><span>fill-in</span></a></li><li><a href="riemann.streams.html#var-fill-in-last"><span>fill-in-last</span></a></li><li><a href="riemann.streams.html#var-forward"><span>forward</span></a></li><li><a href="riemann.streams.html#var-interpolate-constant"><span>interpolate-constant</span></a></li><li><a href="riemann.streams.html#var-match"><span>match</span></a></li><li><a href="riemann.streams.html#var-mean-over-time"><span>mean-over-time</span></a></li><li><a href="riemann.streams.html#var-over"><span>over</span></a></li><li><a href="riemann.streams.html#var-part-time-fast"><span>part-time-fast</span></a></li><li><a href="riemann.streams.html#var-percentiles"><span>percentiles</span></a></li><li><a href="riemann.streams.html#var-periodically-until-expired"><span>periodically-until-expired</span></a></li><li><a href="riemann.streams.html#var-rate"><span>rate</span></a></li><li><a href="riemann.streams.html#var-register"><span>register</span></a></li><li><a href="riemann.streams.html#var-rollup"><span>rollup</span></a></li><li><a href="riemann.streams.html#var-sum-over-time"><span>sum-over-time</span></a></li><li><a href="riemann.streams.html#var-tagged-all"><span>tagged-all</span></a></li><li><a href="riemann.streams.html#var-tagged-any"><span>tagged-any</span></a></li><li><a href="riemann.streams.html#var-throttle"><span>throttle</span></a></li><li><a href="riemann.streams.html#var-under"><span>under</span></a></li><li><a href="riemann.streams.html#var-update-index"><span>update-index</span></a></li><li><a href="riemann.streams.html#var-where"><span>where</span></a></li><li><a href="riemann.streams.html#var-where-rewrite"><span>where-rewrite</span></a></li><li><a href="riemann.streams.html#var-within"><span>within</span></a></li><li><a href="riemann.streams.html#var-without"><span>without</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>riemann.streams documentation</h2><pre class="doc">Streams are functions which accept events (or, in some cases, lists of
events). They can filter those events, transform them, apply them to other
streams, combine them over time, update state, forward to other services, and
more. Most streams accept, after their initial arguments, any number of
streams as children. When invoking children, they typically catch all
exceptions and log them, then proceed to the next child.

Any function accepting an event map (e.g. {:service &quot;foo&quot; :metric 3.5} can
be a stream. prn is a stream. So is (partial log :info), or (fn [x]). The
streams namespace aims to provide a comprehensive set of widely applicable,
combinable tools for building up more complicated streams.</pre><div class="public" id="var-append"><h3>append</h3><div class="usage"><code>(append reference)</code></div><pre class="doc">Conj events onto the given reference
</pre></div><div class="public" id="var-by"><h3>by</h3><div class="usage"><code>(by fields &amp; children)</code></div><pre class="doc">Splits stream by field.
Every time an event arrives with a new value of field, this macro invokes
its child forms to return a *new*, distinct set of streams for that
particular value.

(rate 5 prn) prints a single rate for all events, once every five seconds.

(by :host (rate 5) tracks a separate rate for *each host*, and prints each 
one every five seconds.

You can pass multiple fields too

(by [:host :service])

Note that field can be a keyword like :host or :state, but you can *also* use
any unary function for more complex sharding.

Be aware that (by) over unbounded values can result in
*many* substreams being created, so you wouldn't want to write
(by metric prn): you'd get a separate prn for *every* unique metric that 
came in.</pre></div><div class="public" id="var-call-rescue"><h3>call-rescue</h3><div class="usage"><code>(call-rescue event children)</code></div><pre class="doc">Call each child, in order, with event. Rescues and logs any failure.
</pre></div><div class="public" id="var-changed"><h3>changed</h3><div class="usage"><code>(changed pred &amp; children)</code></div><pre class="doc">Passes on events only when (f event) differs from that of the previous
event. Options:

:init   The initial value to assume for (pred event).

; Print all state changes
(changed :state prn)

; Assume states *were* ok the first time we see them.
(changed :state {:init &quot;ok&quot;} prn)

Note that f can be an arbitrary function:

(changed (fn [e] (&gt; (:metric e) 2)) ...)</pre></div><div class="public" id="var-changed-state"><h3>changed-state</h3><div class="usage"><code>(changed-state &amp; children)</code></div><pre class="doc">Passes on changes in state for each distinct host and service.
</pre></div><div class="public" id="var-coalesce"><h3>coalesce</h3><div class="usage"><code>(coalesce &amp; children)</code></div><pre class="doc">Combines events over time. Coalesce remembers the most recent event for each
service that passes through it (limited by :ttl). Every time it receives an
event, it passes on *all* events it remembers.

Use coalesce to combine states that arrive at different times--for instance,
to average the CPU use over several hosts.</pre></div><div class="public" id="var-combine"><h3>combine</h3><div class="usage"><code>(combine f &amp; children)</code></div><pre class="doc">Returns a function which takes a seq of events. Combines events with f, then
forwards the result to children.</pre></div><div class="public" id="var-counter"><h3>counter</h3><div class="usage"><code>(counter &amp; children)</code></div><pre class="doc">Counts things. All metrics are summed together; passes on each event with
the summed metric. When an event has tag &quot;reset&quot;, resets the counter to
zero and continues summing.</pre></div><div class="public" id="var-ddt"><h3>ddt</h3><div class="usage"><code>(ddt &amp; args)</code></div><pre class="doc">Differentiate metrics with respect to time. With no args, emits an event for
each one received, but with metric equal to the difference between the
current event and the previous one, divided by the difference in their times.
If the first argument is a number n, emits a rate-of-change event every n
seconds instead, until expired. Skips events without metrics.</pre></div><div class="public" id="var-delete-from-index"><h3>delete-from-index</h3><div class="usage"><code>(delete-from-index index)</code></div><pre class="doc">Deletes any events that pass through from the index
</pre></div><div class="public" id="var-ewma-timeless"><h3>ewma-timeless</h3><div class="usage"><code>(ewma-timeless r &amp; children)</code></div><pre class="doc">Exponential weighted moving average. Constant space and time overhead.
Passes on each event received, but with metric adjusted to the moving
average. Does not take the time between events into account.</pre></div><div class="public" id="var-expired"><h3>expired</h3><div class="usage"><code>(expired &amp; children)</code></div><pre class="doc">Passes on events with :state &quot;expired&quot;.
</pre></div><div class="public" id="var-expired%3F"><h3>expired?</h3><div class="usage"><code>(expired? event)</code></div><pre class="doc">There are two ways an event can be considered expired. First, if it has state &quot;expired&quot;. Second, if its :ttl and :time indicates it has expired.
</pre></div><div class="public" id="var-fill-in"><h3>fill-in</h3><div class="usage"><code>(fill-in interval default-event &amp; children)</code></div><pre class="doc">Passes on all events. Fills in gaps in event stream with copies of the given
event, wherever interval seconds pass without an event arriving. Inserted
events have current time. Stops inserting when expired. Uses local times.</pre></div><div class="public" id="var-fill-in-last"><h3>fill-in-last</h3><div class="usage"><code>(fill-in-last interval update &amp; children)</code></div><pre class="doc">Passes on all events. Fills in gaps in event stream with copies of the last
event merged with the given data, wherever interval seconds pass without an
event arriving. Inserted events have current time. Stops inserting when
expired. Uses local times.</pre></div><div class="public" id="var-forward"><h3>forward</h3><div class="usage"><code>(forward client)</code></div><pre class="doc">Sends an event through a client
</pre></div><div class="public" id="var-interpolate-constant"><h3>interpolate-constant</h3><div class="usage"><code>(interpolate-constant interval &amp; children)</code></div><pre class="doc">Emits a constant stream of events every interval seconds, starting when an
event is received, and ending when an expired event is received. Times are
set to Riemann's time. The first and last events are forwarded immediately.

Note: ignores event times currently--will change later.</pre></div><div class="public" id="var-match"><h3>match</h3><div class="usage"><code>(match f value &amp; children)</code></div><pre class="doc">Passes events on to children only when (f event) is equal to value. If f is
a regex, uses re-matches?</pre></div><div class="public" id="var-mean-over-time"><h3>mean-over-time</h3><div class="usage"><code>(mean-over-time children)</code></div><pre class="doc">Emits the most recent event each time this stream is called, but with the
average of all received metrics.</pre></div><div class="public" id="var-over"><h3>over</h3><div class="usage"><code>(over x &amp; children)</code></div><pre class="doc">Passes on events only when their metric is greater than x
</pre></div><div class="public" id="var-part-time-fast"><h3>part-time-fast</h3><div class="usage"><code>(part-time-fast interval create add finish)</code></div><pre class="doc">Partitions events by time (fast variant). Each &lt;interval&gt; seconds, creates a
new bin by calling (create). Applies each received event to the current bin
with (add bin event). When the time interval is over, calls (finish bin
start-time elapsed-time).</pre></div><div class="public" id="var-percentiles"><h3>percentiles</h3><div class="usage"><code>(percentiles interval points &amp; children)</code></div><pre class="doc">Over each period of interval seconds, aggregates events and selects one
event from that period for each point. If point is 0, takes the lowest metric
event.  If point is 1, takes the highest metric event. 0.5 is the median
event, and so forth. Forwards each of these events to children. The service
name has the point appended to it; e.g. 'response time' becomes 'response
time .95'.</pre></div><div class="public" id="var-periodically-until-expired"><h3>periodically-until-expired</h3><div class="usage"><code>(periodically-until-expired f)</code><code>(periodically-until-expired interval f)</code><code>(periodically-until-expired interval delay f)</code></div><pre class="doc">When an event arrives, begins calling f every interval seconds. Starts
after delay. Stops calling f when an expired? event arrives.</pre></div><div class="public" id="var-rate"><h3>rate</h3><div class="usage"><code>(rate interval &amp; children)</code></div><pre class="doc">Take the sum of every event over interval seconds and divide by the interval
size.</pre></div><div class="public" id="var-register"><h3>register</h3><div class="usage"><code>(register reference)</code></div><pre class="doc">Set reference to the most recent event that passes through.
</pre></div><div class="public" id="var-rollup"><h3>rollup</h3><div class="usage"><code>(rollup n m &amp; children)</code></div><pre class="doc">Invokes children with events at most n times per m second interval. Passes 
*vectors* of events to children, not a single event at a time. For instance, 
(rollup 3 1 f) receives five events and forwards three times per second:

1 -&gt; (f [1])
2 -&gt; (f [2])
3 -&gt; (f [3])
4 -&gt;
5 -&gt; 

... and events 4 and 5 are rolled over into the next period:

  -&gt; (f [4 5])</pre></div><div class="public" id="var-sum-over-time"><h3>sum-over-time</h3><div class="usage"><code>(sum-over-time &amp; children)</code></div><pre class="doc">Sums all metrics together. Emits the most recent event each time this
stream is called, but with summed metric.</pre></div><div class="public" id="var-tagged-all"><h3>tagged-all</h3><div class="usage"><code>(tagged-all tags &amp; children)</code></div><pre class="doc">Passes on events where all tags are present.

(tagged-all &quot;foo&quot; prn)
(tagged-all [&quot;foo&quot; &quot;bar&quot;] prn)</pre></div><div class="public" id="var-tagged-any"><h3>tagged-any</h3><div class="usage"><code>(tagged-any tags &amp; children)</code></div><pre class="doc">Passes on events where any of tags are present.

(tagged-any &quot;foo&quot; prn)
(tagged-all [&quot;foo&quot; &quot;bar&quot;] prn)</pre></div><div class="public" id="var-throttle"><h3>throttle</h3><div class="usage"><code>(throttle n m &amp; children)</code></div><pre class="doc">Passes on n events every m seconds. Drops events when necessary.
</pre></div><div class="public" id="var-under"><h3>under</h3><div class="usage"><code>(under x &amp; children)</code></div><pre class="doc">Passes on events only when their metric is smaller than x
</pre></div><div class="public" id="var-update-index"><h3>update-index</h3><div class="usage"><code>(update-index index)</code></div><pre class="doc">Updates the given index with all events received.
</pre></div><div class="public" id="var-where"><h3>where</h3><div class="usage"><code>(where expr &amp; children)</code></div><pre class="doc">Passes on events where expr is true. Expr is rewritten using where-rewrite.
'event is bound to the event under consideration. Examples:

; Match any event where metric is either 1, 2, 3, or 4.
(where (metric 1 2 3 4) ...)

; Match a event where the metric is negative AND the state is ok.
(where (and (&gt; 0 metric)
            (state &quot;ok&quot;)) ...)

; Match a event which has expired.
(where (expired? event) ...)

; Match a event where the host begins with web
(where (host #&quot;^web&quot;) ...)</pre></div><div class="public" id="var-where-rewrite"><h3>where-rewrite</h3><div class="usage"><code>(where-rewrite expr)</code></div><pre class="doc">Rewrites lists recursively. Replaces (metric x y z) with a test matching
(:metric event) to any of x, y, or z, either by = or re-find. Replaces any
other instance of metric with (:metric event). Does the same for host,
service, event, state, time, ttl, tags (which performs an exact match of the
tag vector), tagged (which checks to see if the given tag is present at all),
metric_f, and description.</pre></div><div class="public" id="var-within"><h3>within</h3><div class="usage"><code>(within r &amp; children)</code></div><pre class="doc">Passes on events only when their metric falls within the given inclusive
range.

(within [0 1] (fn [event] do-something))</pre></div><div class="public" id="var-without"><h3>without</h3><div class="usage"><code>(without r &amp; children)</code></div><pre class="doc">Passes on events only when their metric falls outside the given (inclusive)
range.</pre></div></div></body></html>